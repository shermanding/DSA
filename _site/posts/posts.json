[
  {
    "path": "posts/Post2/",
    "title": "Replicating payoff of digital option",
    "description": "We explore payoff replication of exotic options using a portfolio on vanilla options. We investigate how well the replication is and what factors affect the payoff.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2022-01-03",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n1.0 Define digital option\r\npayoff\r\nWe consider a digital option with a payoff at maturity T = 1, where L\r\n= 80, U = 120. L and U and lower barriers and upper barriers\r\nrespectively. The digital option pays $1 if Stock price remains in\r\nbetween the barriers.\r\n\\[\r\n1_{L < S_T < U}\r\n\\]\r\n\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\ndef binary_call_payoff(S_T):\r\n  if S_T > 80 and S_T < 120:\r\n    return 1.0\r\n  else:\r\n    return 0.0\r\n  \r\nprice = []\r\npayoff = []\r\n\r\nfor stock in np.arange(70,130,0.1):\r\n    price.append(stock)\r\n    payoff.append(binary_call_payoff(stock))\r\n    \r\nplt.plot(price,payoff)\r\nplt.title('Digital Option Payoff')\r\nplt.show()\r\n\r\n\r\n2.0 Replicate payoff of\r\ndigital option\r\nWe replicate the digital option payoff above by combining european\r\nvanilla option spreads:\r\nLong vertical call spread (long call @ \\(80 - \\epsilon\\), short call @ \\(80 + \\epsilon\\))\r\nShort vertical call spread (short call @ \\(80 - \\epsilon\\), long call @ \\(80 + \\epsilon\\))\r\n\\[\r\nC_0(Digital) = \\lim_{\\epsilon \\rightarrow 0} \\frac{Call(80 - \\epsilon) -\r\nCall(80 + \\epsilon)}{2\\epsilon} = -\\frac{dCall}{dK}\r\n\\]\r\nThe digital call can be thought of as a limit of a call spread. As\r\nthe distance between the call spread strikes and the digital strikes\r\n\\(\\epsilon\\) get smaller, \\(\\frac{1}{\\epsilon}\\) call spreads with\r\n2\\(\\epsilon\\) width are needed to\r\nreplicate the digital option. This means in the limit, as \\(\\epsilon\\) tends to 0, the call spread can\r\nreplicate the digital option exactly. Below plot shows the replication\r\nof a digital option payoff using 2 call spreads; as \\(\\epsilon\\) becomes smaller, the spreads\r\nreplicate the digital option payoff more and more perfectly.\r\n\r\npayoff_list1 = []\r\npayoff_list2 = []\r\npayoff_list3 = []\r\ns_price1 = []\r\ns_price2 = []\r\ns_price3 = []\r\nepsilon_var=(0.1,0.5,1)\r\n\r\nfor j in range(len(epsilon_var)):\r\n    S=70\r\n    s_tick=0.1\r\n    payout = 0.5 # per call spread leg (total payout=1)\r\n    epsilon=epsilon_var[j]\r\n    lots = payout*2/epsilon \r\n    K1=80-epsilon\r\n    K2=80+epsilon\r\n    K3=120-epsilon\r\n    K4=120+epsilon\r\n    \r\n    for i in np.arange(70.0,130,s_tick):\r\n        payoff=0\r\n        S+=s_tick\r\n        if S>K1:\r\n            payoff+=(payout*lots)*(S-K1)\r\n        if S>K2:\r\n            payoff-=(payout*lots)*(S-K2)\r\n        if S>K3:\r\n            payoff-=(payout*lots)*(S-K3)\r\n        if S>K4:\r\n            payoff+=(payout*lots)*(S-K4)\r\n        if epsilon == 0.1:      \r\n            payoff_list1.append(payoff)\r\n            s_price1.append(S)\r\n        elif epsilon == 0.5:\r\n            payoff_list2.append(payoff)\r\n            s_price2.append(S)\r\n        elif epsilon == 1:\r\n            payoff_list3.append(payoff)\r\n            s_price3.append(S)\r\n    \r\nplt.plot(s_price1,payoff_list1)\r\nplt.plot(s_price2,payoff_list2)\r\nplt.plot(s_price3,payoff_list3)\r\nplt.title('Spread Replication Payoff')\r\nplt.legend(['epsilon = 0.1','epsilon = 0.5','epsilon = 1'])\r\nplt.show()\r\n\r\n\r\nIt is important to note that while \\(\\epsilon\\) is not 0, it does not perfectly\r\nreplicate a digital option payoff:\r\nAbove the barrier level, the call spread has the same payoff as the\r\ndigital option\r\nBelow the barrier level, the call spread the same payoff as the\r\ndigital option\r\nIn-between the upper and lower strikes, the call spread has a\r\nnon-zero payoff\r\nThe call-spread over-replicates the digital option because its payoff\r\nis always greater, or equal to the digital option payoff.\r\n3.0\r\nBlack-Scholes Delta and Vega profiles of digital option\r\nIt is shown that the smaller the \\(\\epsilon\\), the closer the call spread is\r\nin replicating the digital option payoff. By using \\(\\epsilon\\) = 0.1, we can set the call\r\nspread strikes required for the digital option.\r\nK1 = 80 - 0.1 = 79.9\r\nK2 = 80 + 0.1 = 80.1\r\nK3 = 80 - 0.1 = 119.9\r\nK4 = 80 + 0.1 = 120.1\r\nSince \\(\\epsilon\\) is set at 0.1, we\r\nwould need 1/\\(\\epsilon\\) amount of\r\ncontracts per call spread. Therefore we have 1/0.1 = 10\r\ncontracts per call spread\r\n\r\nfrom scipy.stats import norm\r\nimport numpy as np\r\nfrom matplotlib import style\r\n\r\nsigma = 0.2\r\nr = 0\r\nq = 0\r\nT = 1\r\ns_tick = 0.1\r\nK1 = 79.9\r\nK2 = 80.1\r\nK3 = 119.9\r\nK4 = 120.1\r\ndelta_profile = []\r\nstock_price = []\r\n\r\ndef BS_Call_Delta(F,K,q,sigma,T):\r\n    d1 = (np.log(F/K)+(0.5*sigma**2*T)) / sigma*np.sqrt(T)\r\n    return np.exp(-q*T) * norm.cdf(d1)\r\n\r\nfor S in np.arange(0.1,240,s_tick):\r\n    Forward = S * np.exp(-r*T)\r\n    call_spread1 = 10*(BS_Call_Delta(Forward,K1,q,sigma,T) - BS_Call_Delta(Forward,K2,q,sigma,T))\r\n    call_spread2 = 10*(-BS_Call_Delta(Forward,K3,q,sigma,T) + BS_Call_Delta(Forward,K4,q,sigma,T))\r\n    delta_profile.append(call_spread1 + call_spread2)\r\n    stock_price.append(S)\r\n\r\nwith plt.style.context('seaborn'):    \r\n    plt.plot(stock_price,delta_profile)\r\n    plt.title('Digital Option Delta Profile (BS)')\r\nplt.show()\r\n\r\n\r\n\r\nsigma = 0.2\r\nr = 0\r\nq = 0\r\nT = 1\r\ns_tick = 0.1\r\nK1 = 79.9\r\nK2 = 80.1\r\nK3 = 119.9\r\nK4 = 120.1\r\nvega_profile = []\r\nstock_price_ = []\r\n\r\ndef BS_Call_Vega(S0,F,K,q,sigma,T):\r\n    d1 = (np.log(F/K)+(0.5*sigma**2*T)) / sigma*np.sqrt(T)\r\n    return np.exp(-q*T) * S0 * np.sqrt(T) * norm.pdf(d1)\r\n\r\nfor S in np.arange(0.1,240,s_tick):\r\n    Forward = S * np.exp(-r*T)\r\n    call_spread1 = 10*(BS_Call_Vega(S,Forward,K1,q,sigma,T) - BS_Call_Vega(S,Forward,K2,q,sigma,T))\r\n    call_spread2 = 10*(-BS_Call_Vega(S,Forward,K3,q,sigma,T) + BS_Call_Vega(S,Forward,K4,q,sigma,T))\r\n    vega_profile.append(call_spread1 + call_spread2)\r\n    stock_price_.append(S)\r\n\r\nwith plt.style.context('seaborn'):    \r\n    plt.plot(stock_price_,vega_profile)\r\n    plt.title('Digital Option Vega Profile (BS)')\r\nplt.show()\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/Post2/Post2_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2022-07-17T22:03:53+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-09-dsa/",
    "title": "Using R to visualize data",
    "description": "We use popular R packages to visualize static data through histograms.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2021-09-09",
    "categories": [],
    "contents": "\r\n1.0 Overview\r\nCorrelation coefficient is a popular statistic that use to measure\r\nthe type and strength of the relationship between two variables. The\r\nvalues of a correlation coefficient ranges between -1.0 and 1.0. A\r\ncorrelation coefficient of 1 shows a perfect linear relationship between\r\nthe two variables, while a -1.0 shows a perfect inverse relationship\r\nbetween the two variables. A correlation coefficient of 0.0 shows no\r\nlinear relationship between the two variables.\r\nWhen multivariate data are used, the correlation coefficients of the\r\npair comparisons are displayed in a table form known as correlation\r\nmatrix or scatter-plot matrix.\r\nThere are three broad reasons for computing a correlation matrix.\r\nTo reveal the relationship between high-dimensional variables\r\npair-wisely.\r\nTo input into other analyses. For example, people commonly use\r\ncorrelation matrices as inputs for exploratory factor analysis,\r\nconfirmatory factor analysis, structural equation models, and linear\r\nregression when excluding missing values pairwise.\r\nAs a diagnostic when checking other analyses. For example, with\r\nlinear regression a high amount of correlations suggests that the linear\r\nregression’s estimates will be unreliable.\r\nWhen the data is large, both in terms of the number of observations\r\nand the number of variables, Corrgram tend to be\r\nused to visually explore and analyse the structure and the patterns of\r\nrelations among variables. It is designed based on two main schemes:\r\nRendering the value of a correlation to depict its sign and\r\nmagnitude, and\r\nReordering the variables in a correlation matrix so that “similar”\r\nvariables are positioned adjacently, facilitating perception.\r\nIn this hands-on exercise, you will learn how to plot data\r\nvisualisation for visualising correlation matrix with R. It consists of\r\nthree main sections. First, you will learn how to create correlation\r\nmatrix using pairs()\r\nof R Graphics. Next, you will learn how to plot corrgram using\r\ncorrplot package of R Lastly, you will learn how to\r\ncreate an interactive correlation matrix using plotly R. .\r\n2.0 Installing and\r\nLaunching R Packages\r\nBefore you get started, you are required:\r\nto start a new R project, and\r\nto create a new R Markdown document.\r\nNext, you will use the code chunk below to install and launch\r\ncorrplot, ggpubr,\r\nplotly and tidyverse in RStudio.\r\n\r\n\r\npackages = c('ggpubr', 'tidyverse')\r\n\r\nfor(p in packages){library\r\n  if(!require(p, character.only = T)){\r\n    install.packages(p)\r\n  }\r\n  library(p, character.only = T)\r\n}\r\n\r\n\r\n\r\n3.0 Importing and\r\nPreparing The Data Set\r\nIn this hands-on exercise, the Wine Quality\r\nData Set of UCI Machine Learning Repository will be used. The data\r\nset consists of 13 variables and 6497 observations. For the purpose of\r\nthis exercise, we have combined the red wine and white wine data into\r\none data file. It is called wine_quality and is in csv file format.\r\n3.1 Importing Data\r\nFirst, let us import the data into R by using read_csv() of\r\nreadr package.\r\n\r\n\r\nwine <- read_csv(\"data/wine_quality.csv\")\r\n\r\n\r\n\r\nNotice that beside quality and type, the rest of the variables are\r\nnumerical and continuous data type.\r\n4.0 Univariate EDA with\r\nHistogram\r\nIn the figure below, multiple histograms are plottted to reveal the\r\ndistribution of the selected variables in the wine quality data\r\nsets.\r\n\r\n\r\n\r\nThe code chunks used to create the data visualisation consists of two\r\nmain parts. First, we will create the individual histograms using the\r\ncode chunk below.\r\n\r\n\r\nfa <- ggplot(data=wine, aes(x= `fixed acidity`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nva <- ggplot(data=wine, aes(x= `volatile acidity`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nca <- ggplot(data=wine, aes(x= `citric acid`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nrs <- ggplot(data=wine, aes(x= `residual sugar`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nch <- ggplot(data=wine, aes(x= `chlorides`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nfSO2 <- ggplot(data=wine, aes(x= `free sulfur dioxide`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\ntSO2 <- ggplot(data=wine, aes(x= `total sulfur dioxide`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\ndensity <- ggplot(data=wine, aes(x= density)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\npH <- ggplot(data=wine, aes(x= pH)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nsulphates <- ggplot(data=wine, aes(x= sulphates)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nalcohol <- ggplot(data=wine, aes(x= alcohol)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\n\r\n\r\n\r\nNext, the ggarrange function of ggpur\r\npackage is used to group these histograms together.\r\n\r\n\r\nggarrange(fa, va, ca, rs, ch, fSO2, tSO2, density, pH, sulphates, alcohol, \r\n          ncol = 4, nrow = 3)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-09-09-dsa/dsa_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-07-17T22:49:39+08:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Motivations behind QuantWeave",
    "description": "A deep-dive into quantitative methods and data science to solve real-world problems. I started this blog as a medium to bridge quasi-methods to the world of finance.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2021-09-08",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-17T22:50:59+08:00",
    "input_file": {}
  }
]
