[
  {
    "path": "posts/2022-07-18-modelling-probability-of-an-event-using-poisson-process/",
    "title": "Modelling probability of an event using poisson process",
    "description": "We look at how to model the probabability of an event by using jumps in a poisson process.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2022-07-18",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n1.0 The Poisson Process\r\nAssuming the event to be exactly one asset jump arrival within the\r\ninterval \\(\\left[0,T\\right]\\), how can\r\nwe determine the probability of this jump:\r\nWe consider a Poisson process and we denote the time of the n-th jump\r\nby \\(T_n\\). The sequence {\\(T_1,T_2,...T_n\\)} is the sequence of\r\narrival(or jump) times. The number of events in a time interval \\(\\Delta t\\) is poisson distributed with mean\r\n\\(\\lambda \\Delta t\\) for all t \\(\\ge\\) 0, with arrival intensity \\(\\lambda\\):\r\n\\[\r\nProb\\left(N_{t+\\Delta t} - N_t = n\\right) = e^{-\\lambda \\Delta\r\n\\frac{T}{2}} \\frac{\\left(\\lambda \\Delta \\frac{T}{2}\\right)^n}{n!}, n =\r\n0,1,...\r\n\\]\r\nEvent A Let Event A be the probability of 1 asset\r\njump in a given time interval \\(\\left[0,T\\right]\\), n = 1.\r\n\\[\r\nProb\\left(N_{t+\\Delta t} - N_t = 1\\right) = e^{-\\lambda T}\r\n\\frac{\\left(\\lambda T\\right)^1}{1!}\r\n\\\\\r\nProb\\left(A\\right) = \\lambda Te^{-\\lambda T}\r\n\\]\r\nThe probability of Event A is \\(\\lambda\r\nTe^{-\\lambda T}\\).\r\n2.0\r\nProperties of the poisson process, and mathematical proof\r\nHow can we prove that the probability of the event of exactly one\r\nasset jump within the interval \\(\\left[0,T\\right]\\) is the same as:\r\n1 asset jump in the interval \\(\\left[0,\\frac{T}{2}\\right)\\), and no asset\r\njump in the interval \\(\\left[\\frac{T}{2},T\\right]\\).\r\nNo asset jumps in the interval \\(\\left[0,\\frac{T}{2}\\right)\\), and 1 asset\r\njump in the interval \\(\\left[\\frac{T}{2},T\\right]\\).\r\nWe consider a Poisson process and we denote the time of the n-th jump\r\nby \\(T_n\\). The sequence {\\(T_1,T_2,...T_n\\)} is the sequence of\r\narrival(or jump) times. The number of events in a time interval \\(\\Delta t\\) is poisson distributed with mean\r\n\\(\\lambda \\Delta t\\) for all t \\(\\ge\\) 0:\r\n\\[\r\nProb\\left(N_{t+\\Delta t} - N_t = n\\right) = e^{-\\lambda \\Delta\r\n\\frac{T}{2}} \\frac{\\left(\\lambda \\Delta \\frac{T}{2}\\right)^n}{n!}, n =\r\n0,1,...\r\n\\]\r\nExpectation (Mean) is given as: E\\(\\left[N_{t+\\Delta t} - N_t\\right] = \\lambda \\Delta\r\nt\\)\r\nWe know that the Poisson process is:\r\nIndependent and Identically distributed\r\nA discrete probability distribution of a sum of independent\r\nBernoilli trials\r\nThis means that at any point in time, the Poisson process\r\nprobabilistically restarts itself.\r\nEvent X\r\nLet Event X be the probability of exactly 1 jump from interval \\(\\left[0,\\frac{T}{2}\\right)\\) and 0 jump\r\nfrom interval \\(\\left[\\frac{T}{2},T\\right]\\), where \\(X_1\\) = 1 and \\(X_2\\) = 0:\r\nFirst, we find the probability of 1 jump occuring in the interval\r\n\\(\\left[0,\\frac{T}{2}\\right)\\):\r\n\\[\r\nProb\\left(N_t = 1\\right) = Prob\\left(X_1 = 1\\right)= e^{-\\lambda\r\n\\frac{T}{2}}\\frac{\\left(\\lambda \\frac{T}{2}\\right)^n}{n!} = e^{-\\lambda\r\n\\frac{T}{2}} \\frac{\\lambda T}{2}\r\n\\]\r\nFor interval \\(\\left[\\frac{T}{2},T\\right]\\), the interval\r\nlength is the same as the first interval \\(\\left[0,\\frac{T}{2}\\right]\\). We can find\r\nthe probability of 0 jump occuring in this interval:\r\n\\[\r\nProb\\left(N_t = 0\\right) = Prob\\left(X_2 = 0\\right) = e^{-\\lambda\r\n\\frac{T}{2}}\r\n\\]\r\nWe can find the probability of Event X occuring\r\nbelow:\r\nWhere Event X is Prob(\\(X_2 = 0\\)) conditional on Prob(\\(X_1 = 1\\)) for interval \\(\\left[0,\\frac{T}{2}\\right)\\)\r\n\\[\r\nProb\\left(X_1 = 1\\right) \\times Prob\\left(X_2 = 0\\right) = e^{-\\lambda\r\n\\frac{T}{2}} \\frac{\\lambda T}{2} \\times e^{-\\lambda \\frac{T}{2}}\r\n\\\\\r\n\\\\\r\nProb\\left(X\\right) = Prob\\left(X_2 = 0 | X_1 = 1\\right) = e^{-\\lambda T}\r\n\\left(\\frac{\\lambda T}{2}\\right)\r\n\\]\r\n\r\nEvent Y\r\nLet Event Y be the probability of 0 jump from interval \\(\\left[0,\\frac{T}{2}\\right)\\) and exactly 1\r\njump from interval \\(\\left[\\frac{T}{2},T\\right]\\):\r\nFirst, we find the probability of 0 jump occuring in the interval\r\n\\(\\left[0,\\frac{T}{2}\\right)\\):\r\n\\[\r\nProb\\left(N_t = 0\\right) = Prob\\left(Y_1 = 0\\right) = e^{-\\lambda\r\n\\frac{T}{2}}\r\n\\]\r\nFor interval \\(\\left[\\frac{T}{2},T\\right]\\), the interval\r\nlength is the same as the first interval \\(\\left[0,\\frac{T}{2}\\right]\\). We can find\r\nthe probability of 1 jump occuring in this interval:\r\n\\[\r\nProb\\left(N_t = 1\\right) = Prob\\left(Y_2 = 1\\right) = e^{-\\lambda\r\n\\frac{T}{2}}\\frac{\\left(\\lambda \\frac{T}{2}\\right)^n}{n!} = e^{-\\lambda\r\n\\frac{T}{2}} \\frac{\\lambda T}{2}\r\n\\]\r\nWe can find the probability of Event Y occuring\r\nbelow:\r\nWhere Prob(\\(Y_2 = 1\\)) is\r\nconditional on Prob(\\(Y_1 = 0\\)) for\r\ninterval \\(\\left[0,\\frac{T}{2}\\right)\\)\r\n\\[\r\nProb\\left(Y_1 = 0\\right) \\times Prob\\left(Y_2 = 1\\right) = e^{-\\lambda\r\n\\frac{T}{2}} \\times e^{-\\lambda \\frac{T}{2}} \\frac{\\lambda T}{2}\r\n\\\\\r\n\\\\\r\nProb\\left(Y\\right) = Prob\\left(Y_2 = 1 | Y_1 = 0\\right) = e^{-\\lambda T}\r\n\\left(\\frac{\\lambda T}{2}\\right)\r\n\\]\r\nProbability Comparison\r\nEvent A:\r\n\\(Prob\\left(A\\right) = \\lambda Te^{-\\lambda\r\nT}\\)\r\nEvent X or Event Y:\r\n\\(Prob\\left(X \\cup Y\\right) =\r\nProb\\left(X\\right) + Prob\\left(Y\\right) = e^{-\\lambda T}\r\n\\left(\\frac{\\lambda T}{2}\\right) + e^{-\\lambda T} \\left(\\frac{\\lambda\r\nT}{2}\\right) = \\lambda Te^{-\\lambda T}\\)\r\n3.0 Programming the\r\nmathematical proof\r\nWe can assign arbitrary numbers to the variables and conduct below\r\nchecks:\r\nSet \\(\\lambda\\) = 0.5, T = 1, \\(\\mu\\) = \\(\\lambda\r\n\\frac{T}{2}\\)\r\nCheck that probabilities of both Events X and Y are the same\r\nCalculate probabilities and check against inbuilt Poisson PMF\r\nfunction from Scipy Library\r\n\r\nimport numpy as np\r\n\r\nlamb = 0.5\r\nT = 1\r\nmu = lamb*(T/2)\r\n\r\n# Event X probabilities\r\nProb_X1 = np.exp(-lamb*T/2)*(((lamb*T/2)**1)/1)\r\nProb_X2 = np.exp(-lamb*T/2)\r\n\r\n# Event Y probabilities\r\nProb_Y1 = np.exp(-lamb*T/2)\r\nProb_Y2 = np.exp(-lamb*T/2)*(((lamb*T/2)**1)/1)\r\n\r\nprint('Probability of 1 asset jump in interval [0,T/2]: '+str(Prob_X1))\r\nProbability of 1 asset jump in interval [0,T/2]: 0.19470019576785122\r\nprint('Probability of 0 asset jump in interval [T/2,0]: '+str(Prob_X2))\r\nProbability of 0 asset jump in interval [T/2,0]: 0.7788007830714049\r\nprint('Probability of Event X: '+str(Prob_X1*Prob_X2))\r\nProbability of Event X: 0.15163266492815836\r\nprint('Probability of 1 asset jump in interval [0,T/2]: '+str(Prob_Y1))\r\nProbability of 1 asset jump in interval [0,T/2]: 0.7788007830714049\r\nprint('Probability of 0 asset jump in interval [T/2,0]: '+str(Prob_Y2))\r\nProbability of 0 asset jump in interval [T/2,0]: 0.19470019576785122\r\nprint('Probability of Event Y: '+str(Prob_Y1*Prob_Y2))\r\nProbability of Event Y: 0.15163266492815836\r\n\r\n\r\n# Part A probability\r\nProb_A = np.exp(-lamb*T)*(lamb*T)\r\n\r\nprint('Probability of Event A: '+str(Prob_A))\r\nProbability of Event A: 0.3032653298563167\r\nprint('Probability of Event X or Event Y: '+str(Prob_X1*Prob_X2 + Prob_Y1*Prob_Y2))\r\nProbability of Event X or Event Y: 0.3032653298563167\r\n\r\nWe\r\ncan use the Poisson Probability Mass Function from the Scipy library to\r\ncalculate the individual event probability for each aportioned\r\nintervals:\r\n\r\nfrom scipy.stats import poisson\r\n\r\n# Event X\r\nPMF_X1 = poisson.pmf(1, mu)\r\nPMF_X2 = poisson.pmf(0, mu)\r\n\r\n# Event Y\r\nPMF_Y1 = poisson.pmf(0, mu)\r\nPMF_Y2 = poisson.pmf(1, mu)\r\n\r\nprint('Probability of 1 asset jump in interval [0,T/2]: '+str(PMF_X1))\r\nProbability of 1 asset jump in interval [0,T/2]: 0.19470019576785122\r\nprint('Probability of 0 asset jump in interval [T/2,0]: '+str(PMF_X2))\r\nProbability of 0 asset jump in interval [T/2,0]: 0.7788007830714049\r\nprint('Probability of Event X: '+str(PMF_X1*PMF_X2))\r\nProbability of Event X: 0.15163266492815836\r\nprint('Probability of 0 asset jump in interval [0,T/2]: '+str(PMF_Y1))\r\nProbability of 0 asset jump in interval [0,T/2]: 0.7788007830714049\r\nprint('Probability of 1 asset jump in interval [T/2,0]: '+str(PMF_Y2))\r\nProbability of 1 asset jump in interval [T/2,0]: 0.19470019576785122\r\nprint('Probability of Event Y: '+str(PMF_Y1*PMF_Y2))\r\nProbability of Event Y: 0.15163266492815836\r\n\r\nFinally:\r\n\r\n# Event A vs (Event X or Event Y)\r\nPMF_A = poisson.pmf(1, mu*2)\r\nprint('Probability of Event A: '+str(PMF_A))\r\nProbability of Event A: 0.3032653298563167\r\nprint('Probability of Event X or Event Y in interval [0,T]: '+str(PMF_X1*PMF_X2 + PMF_Y1*PMF_Y2))\r\nProbability of Event X or Event Y in interval [0,T]: 0.3032653298563167\r\n\r\nHence, we have proved that the event of 1 asset jump in interval\r\n\\(\\left[0,T\\right]\\) in Part A gives\r\nrise to the exact same probability as:\r\nThe event of 1 jump in the interval \\(\\left[0,\\frac{T}{2}\\right)\\) and no jumps\r\nin interval \\(\\left[\\frac{T}{2},T\\right]\\)\r\nor\r\nThe event of 0 asset jump in interval \\(\\left[0,\\frac{T}{2}\\right)\\) and 1 jump in\r\ninterval \\(\\left[\\frac{T}{2},T\\right]\\)\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-19T10:10:33+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-03-20-static-replication/",
    "title": "Static replication using Breeden-Litzenberger",
    "description": "We use Breeden-Litzenberger to compute option prices numerically and replicate payoffs statically.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2022-03-20",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n1.0 Breeden-Litzenberger\r\nformula\r\nBL formula states that, any payoff that depends on \\(S_T\\) can be priced with the below\r\nformula:\r\n\\[\r\nV_0 = e^{-rT} V_T \\left(\\left(F_0(T)\\right) \\right) + \\int^{F_0(T)}_{0}\r\nPut(K,T)\\frac{\\delta^2V_T(K)}{\\delta K^2} dK + \\int^{\\infty}_{F_0(T)}\r\nCall(K,T)\\frac{\\delta^2V_T(K)}{\\delta K^2} dK\r\n\\]\r\nIn the examples below, we assume:\r\nr = q = 0\r\n\\(S_0\\) = 1\r\nImplied Volatility \\(\\sum{(K)} = 0.510\r\n- 0.591K + 0.376K^2 - 0.105K^3\\)\r\n\r\nimport numpy as np\r\nfrom scipy.stats import norm\r\nfrom scipy.integrate import quad\r\n\r\ndef ivol_calc(K):\r\n    if K >3:\r\n        return 0.510 - 0.591*3 + 0.376*3**2 - 0.105*3**3 + 0.011*3**4\r\n    else:\r\n        return 0.510 - 0.591*K + 0.376*K**2 - 0.105*K**3 + 0.011*K**4\r\n    \r\ndef Black76Call(F, K, T, DF):\r\n    ivol = ivol_calc(K)\r\n    d1 = (np.log(F/K)+(0.5*ivol**2)*T) / (ivol*np.sqrt(T))\r\n    d2 = d1 - ivol*np.sqrt(T)\r\n    return DF*(F*norm.cdf(d1) - K*norm.cdf(d2))\r\n          \r\ndef Black76Put(F, K, T, DF):\r\n    ivol = ivol_calc(K)\r\n    d1 = (np.log(F/K)+(0.5*ivol**2)*T) / (ivol*np.sqrt(T))\r\n    d2 = d1 - ivol*np.sqrt(T)\r\n    return DF*(K*norm.cdf(-d2) - F*norm.cdf(-d1)) \r\n\r\n2.0\r\nStatic replication for option with payoff: \\(V_T(S_T) = \\sqrt(S_T)\\)\r\n\\(V_T(S_T) = \\sqrt{S_T}\\)\r\nThe upper limit of a call integral can be approximated by \\(F_0(T)e^{\\kappa\\sigma\\sqrt{T}}\\) where\r\n\\(\\kappa\\) represents the number of\r\nstandard deviation away from the mean, and \\(\\sigma\\) is ATM implied vol. The higher\r\n\\(\\kappa\\) is, the more accurate the\r\napproximation is.\r\nUsing Breeden-Litzenberger formula, we can use static replication for\r\nthe payoff \\(V_T(S_T) = \\sqrt{S_T}\\)\r\nbelow:\r\n\\[\r\nV_0 = \\sqrt{S_0}e^{\\frac{-rT}{2}} + \\int^{F_0(T)}_{0}\r\n-\\frac{1}{4K^{3/2}} Put(K,T) dK + \\int^{\\infty}_{F_0(T)}\r\n-\\frac{1}{4K^{3/2}} Call(K,T) dK\r\n\\]\r\n\\(h(S_T) = S_T^n\\)\r\n\\(h'(S_T) = nS_T^{n-1}\\)\r\n\\(h''(S_T) =\r\nn(n-1)S_T^{n-2}\\)\r\n\\(h(F) = S_0^ne^{nrT}\\)\r\n\r\ndef h_1(ST):\r\n    return np.sqrt(ST) * np.exp(-r*T/2)\r\n          \r\ndef Numerical_integration1(S0, r, q, T, SD):\r\n    DF = np.exp(-r*T)\r\n    DivF = np.exp(-q*T)\r\n    F = S0 * DivF/DF\r\n    upper_limit = F * np.exp(SD * ivol_calc(F) * np.sqrt(T))\r\n    putintegrand = lambda x: -x**(-1.5) * Black76Put(F, x, T, DF) / 4\r\n    I_put, error = quad(putintegrand, 0, F)\r\n    callintegrand = lambda y: -y**(-1.5) * Black76Call(F, y, T, DF) / 4\r\n    I_call, error = quad(callintegrand, F, upper_limit)\r\n    return h_1(F) + I_put + I_call\r\n\r\nS0 = 1\r\nr = 0\r\nq = 0\r\nT = 4\r\n\r\nSDs = np.linspace(1, 6, 6)\r\nprint([Numerical_integration1(S0, r, q, T, SD) for SD in SDs])\r\n[0.9744529379034821, 0.9737922020437937, 0.9737631318258412, 0.9737624998857587, 0.9737624966161774, 0.9737624965870079]\r\nprint('Option price: %.8f' % [Numerical_integration1(S0, r, q, T, SD) for SD in SDs][-1])\r\nOption price: 0.97376250\r\n\r\nWe see that as kappa increases, the approximation becomes more\r\naccurate.\r\n3.0\r\nStatic replication for option with payoff: \\(V_T(S_T) = S_T^3\\)\r\nUsing Breeden-Litzenberger formula, we can use static replication for\r\nthe payoff \\(V_T(S_T) = S_T^3\\)\r\nbelow:\r\n\\[\r\nV_0 = S_0^3e^{2rT} + \\int^{F_0(T)}_{0} 6K Put(K,T) dK +\r\n\\int^{\\infty}_{F_0(T)} 6K Call(K,T) dK\r\n\\]\r\n\r\ndef h_2(ST):\r\n    return ST**3 * np.exp(2*r*T)\r\n          \r\ndef Numerical_integration2(S0, r, q, T, SD):\r\n    DF = np.exp(-r*T)\r\n    DivF = np.exp(-q*T)\r\n    F = S0 * DivF/DF\r\n    upper_limit = F * np.exp(ivol_calc(F) * SD * np.sqrt(T))\r\n    putintegrand = lambda x: 6 * x * Black76Put(F, x, T, DF)\r\n    I_put, error = quad(putintegrand, 0, F)\r\n    callintegrand = lambda y: 6 * y * Black76Call(F, y, T, DF)\r\n    I_call, error = quad(callintegrand, F, upper_limit)\r\n    return h_2(F) + I_put + I_call\r\n\r\nS0 = 1\r\nr = 0\r\nq = 0\r\nT = 4\r\n\r\nSDs = np.linspace(1, 6, 6)\r\nprint([Numerical_integration2(S0, r, q, T, SD) for SD in SDs])\r\n[1.4563473950073735, 1.5157020030493702, 1.5226686291504845, 1.5230535930213192, 1.5230590092868612, 1.5230590334482683]\r\nprint('Option price: %.8f' % [Numerical_integration2(S0, r, q, T, SD) for SD in SDs][-1])\r\nOption price: 1.52305903\r\n\r\nAgain, we see that as kappa increases, the approximation becomes more\r\naccurate.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-19T10:10:33+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-03-digital-option-payoff/",
    "title": "Replicating payoff of digital option",
    "description": "We explore payoff replication of exotic options using a portfolio on vanilla options. We investigate how well the replication is and what factors affect the payoff.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2022-01-03",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n1.0 Define digital option\r\npayoff\r\nWe consider a digital option with a payoff at maturity T = 1, where L\r\n= 80, U = 120. L and U and lower barriers and upper barriers\r\nrespectively. The digital option pays $1 if Stock price remains in\r\nbetween the barriers.\r\n\\[\r\n1_{L < S_T < U}\r\n\\]\r\n\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\ndef binary_call_payoff(S_T):\r\n  if S_T > 80 and S_T < 120:\r\n    return 1.0\r\n  else:\r\n    return 0.0\r\n  \r\nprice = []\r\npayoff = []\r\n\r\nfor stock in np.arange(70,130,0.1):\r\n    price.append(stock)\r\n    payoff.append(binary_call_payoff(stock))\r\n    \r\nplt.plot(price,payoff)\r\nplt.title('Digital Option Payoff')\r\nplt.show()\r\n\r\n\r\n2.0 Replicate payoff of\r\ndigital option\r\nWe replicate the digital option payoff above by combining european\r\nvanilla option spreads:\r\nLong vertical call spread (long call @ \\(80 - \\epsilon\\), short call @ \\(80 + \\epsilon\\))\r\nShort vertical call spread (short call @ \\(80 - \\epsilon\\), long call @ \\(80 + \\epsilon\\))\r\n\\[\r\nC_0(Digital) = \\lim_{\\epsilon \\rightarrow 0} \\frac{Call(80 - \\epsilon) -\r\nCall(80 + \\epsilon)}{2\\epsilon} = -\\frac{dCall}{dK}\r\n\\]\r\nThe digital call can be thought of as a limit of a call spread. As\r\nthe distance between the call spread strikes and the digital strikes\r\n\\(\\epsilon\\) get smaller, \\(\\frac{1}{\\epsilon}\\) call spreads with\r\n2\\(\\epsilon\\) width are needed to\r\nreplicate the digital option. This means in the limit, as \\(\\epsilon\\) tends to 0, the call spread can\r\nreplicate the digital option exactly. Below plot shows the replication\r\nof a digital option payoff using 2 call spreads; as \\(\\epsilon\\) becomes smaller, the spreads\r\nreplicate the digital option payoff more and more perfectly.\r\n\r\npayoff_list1 = []\r\npayoff_list2 = []\r\npayoff_list3 = []\r\ns_price1 = []\r\ns_price2 = []\r\ns_price3 = []\r\nepsilon_var=(0.1,0.5,1)\r\n\r\nfor j in range(len(epsilon_var)):\r\n    S=70\r\n    s_tick=0.1\r\n    payout = 0.5 # per call spread leg (total payout=1)\r\n    epsilon=epsilon_var[j]\r\n    lots = payout*2/epsilon \r\n    K1=80-epsilon\r\n    K2=80+epsilon\r\n    K3=120-epsilon\r\n    K4=120+epsilon\r\n    \r\n    for i in np.arange(70.0,130,s_tick):\r\n        payoff=0\r\n        S+=s_tick\r\n        if S>K1:\r\n            payoff+=(payout*lots)*(S-K1)\r\n        if S>K2:\r\n            payoff-=(payout*lots)*(S-K2)\r\n        if S>K3:\r\n            payoff-=(payout*lots)*(S-K3)\r\n        if S>K4:\r\n            payoff+=(payout*lots)*(S-K4)\r\n        if epsilon == 0.1:      \r\n            payoff_list1.append(payoff)\r\n            s_price1.append(S)\r\n        elif epsilon == 0.5:\r\n            payoff_list2.append(payoff)\r\n            s_price2.append(S)\r\n        elif epsilon == 1:\r\n            payoff_list3.append(payoff)\r\n            s_price3.append(S)\r\n    \r\nplt.plot(s_price1,payoff_list1)\r\nplt.plot(s_price2,payoff_list2)\r\nplt.plot(s_price3,payoff_list3)\r\nplt.title('Spread Replication Payoff')\r\nplt.legend(['epsilon = 0.1','epsilon = 0.5','epsilon = 1'])\r\nplt.show()\r\n\r\n\r\nIt is important to note that while \\(\\epsilon\\) is not 0, it does not perfectly\r\nreplicate a digital option payoff:\r\nAbove the barrier level, the call spread has the same payoff as the\r\ndigital option\r\nBelow the barrier level, the call spread the same payoff as the\r\ndigital option\r\nIn-between the upper and lower strikes, the call spread has a\r\nnon-zero payoff\r\nThe call-spread over-replicates the digital option because its payoff\r\nis always greater, or equal to the digital option payoff.\r\n3.0\r\nBlack-Scholes Delta and Vega profiles of digital option\r\nIt is shown that the smaller the \\(\\epsilon\\), the closer the call spread is\r\nin replicating the digital option payoff. By using \\(\\epsilon\\) = 0.1, we can set the call\r\nspread strikes required for the digital option.\r\nK1 = 80 - 0.1 = 79.9\r\nK2 = 80 + 0.1 = 80.1\r\nK3 = 80 - 0.1 = 119.9\r\nK4 = 80 + 0.1 = 120.1\r\nSince \\(\\epsilon\\) is set at 0.1, we\r\nwould need 1/\\(\\epsilon\\) amount of\r\ncontracts per call spread. Therefore we have 1/0.1 = 10\r\ncontracts per call spread\r\n\r\nfrom scipy.stats import norm\r\nimport numpy as np\r\nfrom matplotlib import style\r\n\r\nsigma = 0.2\r\nr = 0\r\nq = 0\r\nT = 1\r\ns_tick = 0.1\r\nK1 = 79.9\r\nK2 = 80.1\r\nK3 = 119.9\r\nK4 = 120.1\r\ndelta_profile = []\r\nstock_price = []\r\n\r\ndef BS_Call_Delta(F,K,q,sigma,T):\r\n    d1 = (np.log(F/K)+(0.5*sigma**2*T)) / sigma*np.sqrt(T)\r\n    return np.exp(-q*T) * norm.cdf(d1)\r\n\r\nfor S in np.arange(0.1,240,s_tick):\r\n    Forward = S * np.exp(-r*T)\r\n    call_spread1 = 10*(BS_Call_Delta(Forward,K1,q,sigma,T) - BS_Call_Delta(Forward,K2,q,sigma,T))\r\n    call_spread2 = 10*(-BS_Call_Delta(Forward,K3,q,sigma,T) + BS_Call_Delta(Forward,K4,q,sigma,T))\r\n    delta_profile.append(call_spread1 + call_spread2)\r\n    stock_price.append(S)\r\n\r\nwith plt.style.context('seaborn'):    \r\n    plt.plot(stock_price,delta_profile)\r\n    plt.title('Digital Option Delta Profile (BS)')\r\nplt.show()\r\n\r\n\r\n\r\nsigma = 0.2\r\nr = 0\r\nq = 0\r\nT = 1\r\ns_tick = 0.1\r\nK1 = 79.9\r\nK2 = 80.1\r\nK3 = 119.9\r\nK4 = 120.1\r\nvega_profile = []\r\nstock_price_ = []\r\n\r\ndef BS_Call_Vega(S0,F,K,q,sigma,T):\r\n    d1 = (np.log(F/K)+(0.5*sigma**2*T)) / sigma*np.sqrt(T)\r\n    return np.exp(-q*T) * S0 * np.sqrt(T) * norm.pdf(d1)\r\n\r\nfor S in np.arange(0.1,240,s_tick):\r\n    Forward = S * np.exp(-r*T)\r\n    call_spread1 = 10*(BS_Call_Vega(S,Forward,K1,q,sigma,T) - BS_Call_Vega(S,Forward,K2,q,sigma,T))\r\n    call_spread2 = 10*(-BS_Call_Vega(S,Forward,K3,q,sigma,T) + BS_Call_Vega(S,Forward,K4,q,sigma,T))\r\n    vega_profile.append(call_spread1 + call_spread2)\r\n    stock_price_.append(S)\r\n\r\nwith plt.style.context('seaborn'):    \r\n    plt.plot(stock_price_,vega_profile)\r\n    plt.title('Digital Option Vega Profile (BS)')\r\nplt.show()\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-03-digital-option-payoff/2021-03-03-digital-option-payoff_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2022-07-19T10:14:07+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-09-dsa/",
    "title": "Using R to visualize data",
    "description": "We use popular R packages to visualize static data through histograms.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2021-09-09",
    "categories": [],
    "contents": "\r\n1.0 Overview\r\nCorrelation coefficient is a popular statistic that use to measure\r\nthe type and strength of the relationship between two variables. The\r\nvalues of a correlation coefficient ranges between -1.0 and 1.0. A\r\ncorrelation coefficient of 1 shows a perfect linear relationship between\r\nthe two variables, while a -1.0 shows a perfect inverse relationship\r\nbetween the two variables. A correlation coefficient of 0.0 shows no\r\nlinear relationship between the two variables.\r\nWhen multivariate data are used, the correlation coefficients of the\r\npair comparisons are displayed in a table form known as correlation\r\nmatrix or scatter-plot matrix.\r\nThere are three broad reasons for computing a correlation matrix.\r\nTo reveal the relationship between high-dimensional variables\r\npair-wisely.\r\nTo input into other analyses. For example, people commonly use\r\ncorrelation matrices as inputs for exploratory factor analysis,\r\nconfirmatory factor analysis, structural equation models, and linear\r\nregression when excluding missing values pairwise.\r\nAs a diagnostic when checking other analyses. For example, with\r\nlinear regression a high amount of correlations suggests that the linear\r\nregression’s estimates will be unreliable.\r\nWhen the data is large, both in terms of the number of observations\r\nand the number of variables, Corrgram tend to be\r\nused to visually explore and analyse the structure and the patterns of\r\nrelations among variables. It is designed based on two main schemes:\r\nRendering the value of a correlation to depict its sign and\r\nmagnitude, and\r\nReordering the variables in a correlation matrix so that “similar”\r\nvariables are positioned adjacently, facilitating perception.\r\nIn this hands-on exercise, you will learn how to plot data\r\nvisualisation for visualising correlation matrix with R. It consists of\r\nthree main sections. First, you will learn how to create correlation\r\nmatrix using pairs()\r\nof R Graphics. Next, you will learn how to plot corrgram using\r\ncorrplot package of R Lastly, you will learn how to\r\ncreate an interactive correlation matrix using plotly R. .\r\n2.0 Installing and\r\nLaunching R Packages\r\nBefore you get started, you are required:\r\nto start a new R project, and\r\nto create a new R Markdown document.\r\nNext, you will use the code chunk below to install and launch\r\ncorrplot, ggpubr,\r\nplotly and tidyverse in RStudio.\r\n\r\n\r\npackages = c('ggpubr', 'tidyverse')\r\n\r\nfor(p in packages){library\r\n  if(!require(p, character.only = T)){\r\n    install.packages(p)\r\n  }\r\n  library(p, character.only = T)\r\n}\r\n\r\n\r\n\r\n3.0 Importing and\r\nPreparing The Data Set\r\nIn this hands-on exercise, the Wine Quality\r\nData Set of UCI Machine Learning Repository will be used. The data\r\nset consists of 13 variables and 6497 observations. For the purpose of\r\nthis exercise, we have combined the red wine and white wine data into\r\none data file. It is called wine_quality and is in csv file format.\r\n3.1 Importing Data\r\nFirst, let us import the data into R by using read_csv() of\r\nreadr package.\r\n\r\n\r\nwine <- read_csv(\"data/wine_quality.csv\")\r\n\r\n\r\n\r\nNotice that beside quality and type, the rest of the variables are\r\nnumerical and continuous data type.\r\n4.0 Univariate EDA with\r\nHistogram\r\nIn the figure below, multiple histograms are plottted to reveal the\r\ndistribution of the selected variables in the wine quality data\r\nsets.\r\n\r\n\r\n\r\nThe code chunks used to create the data visualisation consists of two\r\nmain parts. First, we will create the individual histograms using the\r\ncode chunk below.\r\n\r\n\r\nfa <- ggplot(data=wine, aes(x= `fixed acidity`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nva <- ggplot(data=wine, aes(x= `volatile acidity`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nca <- ggplot(data=wine, aes(x= `citric acid`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nrs <- ggplot(data=wine, aes(x= `residual sugar`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nch <- ggplot(data=wine, aes(x= `chlorides`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nfSO2 <- ggplot(data=wine, aes(x= `free sulfur dioxide`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\ntSO2 <- ggplot(data=wine, aes(x= `total sulfur dioxide`)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\ndensity <- ggplot(data=wine, aes(x= density)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\npH <- ggplot(data=wine, aes(x= pH)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nsulphates <- ggplot(data=wine, aes(x= sulphates)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\nalcohol <- ggplot(data=wine, aes(x= alcohol)) +\r\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\r\n\r\n\r\n\r\nNext, the ggarrange function of ggpur\r\npackage is used to group these histograms together.\r\n\r\n\r\nggarrange(fa, va, ca, rs, ch, fSO2, tSO2, density, pH, sulphates, alcohol, \r\n          ncol = 4, nrow = 3)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-09-09-dsa/dsa_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-07-19T10:10:33+08:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Motivations behind QuantWeave",
    "description": "A deep-dive into quantitative methods and data science to solve real-world problems. I started this blog as a medium to bridge quasi-methods to the world of finance.",
    "author": [
      {
        "name": "Sherman Ding",
        "url": "https://www.linkedin.com/in/shermanding93/"
      }
    ],
    "date": "2021-09-08",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-19T10:10:54+08:00",
    "input_file": {}
  }
]
